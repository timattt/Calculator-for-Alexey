# Введение
Это простейший калькулятор.

# Возможности
На данный момент поддерживаются выражения со следующими операторами: +, -, *, /, (, ) и цифры.

# Устройство
В этом проекте 4 исходника:
### Starter.py
Этот файл является основным и должен запускаться, в нем считывается строка из консоли, потом вызывается функция токенизации, из нее получается список токенов, где каждый токен - число или символ (строка), далее создается экземпляр класса TreeBuilder, который отвечает за создание дерева, в его конструктор кладем список токенов. Потом вызываем у него метод G(см. грамматику). Потом забираем единственный элемент поля ancestors (об этом далее) - это будет корень дерева. Далее берем интерпретатор и запускаем функцию run от корня. Она рекурсивно вызывает всех его сыновей, сыновей от сыновей и т.д. Возвращает она значение исходного выражения, которое мы выводим в консоль.

### LexicalAnalyzer.py
Тут происходит токенизация. Описан единственный метод tokenize.
Он принимает на вход строку, а возвращает список токенов.
У него есть переменные operators - список операторов (любой символ из строки, который есть в исходной строке будет выделяться как токен оператор) и divisors - символы, которые игнорируются.

### SyntaxAnalyzer.py
В данном модуле происходит построение дерева.
В нем описан  класс Node. Это нетерминал. У него есть поля: children - указатели на другие Node, который являются его сыновьями; values - список токенов, который забрал данный нетерминал; name - имя узла.

Кстати, вот грамматика:  
G ::= P  
P ::= M {[operator+] M}*  
M ::= T {[operator-] T}*  
T ::= T {[operator*] T}*  
K ::= E {[operator/] E}*  
E ::= [number] | [operator(] P [operator)]   

Далее описан класс TreeBuilder для построения дерева. В нем есть функции для простого взаимоднйствия с токенами,  а так же особоые функции:  collectOperator - требует, чтобы текущий токен был конкретным оператором и отдает этот токен текущему нетерминалу (его полю values, через метод addValue), иначе ошибка. Метод tryOperator - проверяет,  текущий токен является нужным оператором или нет, если да,  то он его прикрепит к нетерминалу и вернет True, иначе вернет False и ничего не произойдет.
Вообще смысл этого класс - построить дерево из нетерминалов по данной строке из токенов. Для этого есть методы climbUp и climbDown, они соответсвуют заходу и выходу в новую вершину дерева (в новый нетерминал), поэтому, кстати, они всегда используются в начале и в конце всех нетерминальных функций, (кроме G, ибо он начальный, а предполагается, чтобы его Node лежал в ancestors). Ancestors - путь от текущей вершины до корня дерева. Его модификацией занимаются два вышеуказанных метода.
     
Остаются только методы грамматики, но они, думаю, не дожны вызвать сложности в понимании, ибо это просто отражение исходной грамматики в коде. 

### Interpretator.py
Здесь лежит метод, который рекурсивно проходит по дереву из нетерминалов, считает значение для каждого поддерева и возращает итоговое значение.
Приведем примеры того, что будет делать эта вещь для разных нетерминалов (говорим о типе нетерминала, как в грамматике):
- run(HEAD) (это должно быть G, но по странным обстоятельствам это стало  HEAD) - просто вернет значение run(HEAD.child)
- run(P) - это правило отвечает за сумму, поэтому она вычислит все возможные run(child[i]) и вернет их сумму.


# Благодарности
Я благодарю моего сокамерника, Алексея Е., который сподвиг меня выложить сию скромную работу (которая задумывалась просто как тренировка программирования на Python) в этот репозиторий.

### Update:  
А сокамерник благодарит автора, Тимура Т., за возможность попрактиковаться в Python и Git с помощью этого проекта.
