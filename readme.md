# Введение
Это простейший калькулятор.

# Возможности
На данный момент поддерживаются выражения со следующими операторами: +, *, (, ) и цифры.

# Устройство
В этом проекте 4 исходника:
### Starter.py
Этот файл нужно запускать, в нем считывается строка из консоли, потом вызывается функция токенизации, из нее получается список токенов, где каждый токен число или символ (строка), далее создается экземпляр класса TreeBuilder, который отвечает за создание дерева, в его конструктор кладем список токенов. Потом вызываем у него метод G. Потом забираем единственный элемент поля ancestors (об этом далее) - это будет корень дерева. Далее берем интерпретатор и запускаем функцию run от корня. Она рекурсивно вызывает всех его сыновей, сыновей от сыновей и т.д. А возвращает она значение значение исходного выражения.
Вот и все теперь его можно и в консоль вывести.

### LexicalAnalyzer.py
Тут происходит токенизация. Опишим единственный метод tokenize.
Он принимает на вход строку, а возвращает список токенов.
У него есть переменные operators - список операторов (любой символ из строки, который есть тут будет выделяться как токен оператор) и divisors - символы, на который пофигу.

### SyntaxAnalyzer.py
А вот тут происходит построение дерева.
Есть класс Node. Это нетерминал. У него есть поля: children - указатели на другие Node, который являются его сыновьями; values - список токенов, который забрал данный нетерминал; name - ну тут все очевидно, ну вы просто смотрите и все сразу видно.

Кстати, вот грамматика:
```
G ::= P  
P ::= T {[operator+] T}*  
T ::= E {[operator*] E}*   
E ::= [number] | [operator(] P [operator)]   
```
Теперь далее будет класс TreeBuilder для построения дерева. В нем есть функции для простого взаимоднйствия с токенами они все понятны, остановлюсь только на collectOperator - требует, чтобы текущий токен был конкретным оператором и отдает этот токен текущему нетерминалу (его полю values, через метод addValue), иначе ошибка. А вот метод tryOperator - проверяет, если текущий токен является нужным оператором, то он его прикрепит к нетерминалу и вернет True, иначе вернет False и ничего не произойдет.
Вообще смысл этого класс - построить дерево из нетерминалов по данной строке из токенов. Для этого есть методы climbUp и climbDown они соотсветсвуют заходу и выходу в новую вершину дерева (в новый нетерминал), поэтому, кстати, они всегда используются в начале и в конце всех нетерминальных функций, (кроме G, ибо он начальный, а я хочу, чтобы его Node лежал в ancestors). Ancestors - путь от текущей вершины - до корня дерева. Его модифицированием занимаются два вышеуказанных метода.
     
Остаются только методы грамматики, но они, думаю, не дожны вызвать сложности в понимании, ибо это просто отражение исходной грамматики в коде. 

### Interpretator.py
Здесь лежит метод, который рекурсивно проходит по дереву из нетерминалов, считает значение для каждого поддерева и возращает итоговое значение.
Приведу примеры, того, что будет делать эта вещь для разных нетерминалов(я говорю о типе нетерминала, как в грамматике):
- run(HEAD) (это должно быть G, не знаю, зачем я так назвал) - просто вернет значение run(HEAD.child)
- run(P) - это штука отвечает за сумму, поэтому она вычислит все возможные run(child[i]) и вернет их сумму.


# Благодарности
Я благодарю моего сокамерника, Алексея Е., который сподвиг меня выложить сию скромную работу (которая задумывалась просто как тренировка программирования на Python) в этот репозиторий.
